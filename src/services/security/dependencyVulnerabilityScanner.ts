/**
 * Dependency Vulnerability Scanner
 * Scans project dependencies for known vulnerabilities using multiple databases
 * Supports multiple package managers and provides detailed vulnerability information
 */

export interface VulnerabilityDatabase {
  name: string;
  url: string;
  lastUpdated: Date;
  totalVulnerabilities: number;
}

export interface PackageInfo {
  name: string;
  version: string;
  ecosystem: string;
  description?: string;
  license?: string;
  homepage?: string;
  repository?: string;
  maintainers?: string[];
  downloads?: number;
  publishedDate?: Date;
  deprecated?: boolean;
}

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  cvss: {
    version: string;
    score: number;
    vector: string;
    baseScore: number;
    temporalScore?: number;
    environmentalScore?: number;
  };
  cwe: string[];
  references: string[];
  publishedDate: Date;
  lastModified: Date;
  affectedVersions: string[];
  patchedVersions: string[];
  exploitAvailable: boolean;
  exploitMaturity: 'unproven' | 'proof-of-concept' | 'functional' | 'high';
  recommendedAction: string;
  vendorAdvisory?: string;
}

export interface DependencyTree {
  package: PackageInfo;
  dependencies: DependencyTree[];
  vulnerabilities: Vulnerability[];
  riskScore: number;
  depth: number;
  isDirect: boolean;
}

export interface LicenseIssue {
  package: string;
  license: string;
  type: 'incompatible' | 'copyleft' | 'unknown' | 'deprecated';
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  recommendation: string;
}

export interface OutdatedPackage {
  package: string;
  currentVersion: string;
  latestVersion: string;
  majorVersionsBehind: number;
  securityUpdates: boolean;
  breakingChanges: boolean;
  updateRecommendation: 'immediate' | 'planned' | 'optional';
}

export interface SupplyChainRisk {
  package: string;
  riskType: 'maintainer_risk' | 'typosquatting' | 'dependency_confusion' | 'malicious_package';
  severity: 'Critical' | 'High' | 'Medium' | 'Low';
  description: string;
  indicators: string[];
  mitigation: string;
}

export interface DependencyScanResult {
  summary: {
    totalPackages: number;
    directDependencies: number;
    transitiveDependencies: number;
    vulnerablePackages: number;
    criticalVulnerabilities: number;
    highVulnerabilities: number;
    mediumVulnerabilities: number;
    lowVulnerabilities: number;
    outdatedPackages: number;
    licenseIssues: number;
    supplyChainRisks: number;
    overallRiskScore: number;
  };
  dependencyTree: DependencyTree[];
  vulnerabilities: Array<{
    package: string;
    version: string;
    vulnerability: Vulnerability;
    path: string[];
    fixAvailable: boolean;
    fixVersion?: string;
  }>;
  licenseIssues: LicenseIssue[];
  outdatedPackages: OutdatedPackage[];
  supplyChainRisks: SupplyChainRisk[];
  recommendations: Array<{
    priority: 'Critical' | 'High' | 'Medium' | 'Low';
    category: 'security' | 'maintenance' | 'license' | 'supply_chain';
    title: string;
    description: string;
    action: string;
    packages: string[];
  }>;
  scanMetadata: {
    scanDate: Date;
    scanDuration: number;
    databasesUsed: string[];
    toolVersion: string;
  };
}

export class DependencyVulnerabilityScanner {
  private vulnerabilityDatabases: VulnerabilityDatabase[] = [
    {
      name: 'National Vulnerability Database (NVD)',
      url: 'https://nvd.nist.gov/',
      lastUpdated: new Date(),
      totalVulnerabilities: 200000
    },
    {
      name: 'GitHub Advisory Database',
      url: 'https://github.com/advisories',
      lastUpdated: new Date(),
      totalVulnerabilities: 50000
    },
    {
      name: 'OSV (Open Source Vulnerabilities)',
      url: 'https://osv.dev/',
      lastUpdated: new Date(),
      totalVulnerabilities: 75000
    }
  ];

  private packageManagers = {
    npm: {
      lockfile: 'package-lock.json',
      manifest: 'package.json',
      registry: 'https://registry.npmjs.org/'
    },
    yarn: {
      lockfile: 'yarn.lock',
      manifest: 'package.json',
      registry: 'https://registry.yarnpkg.com/'
    },
    pip: {
      lockfile: 'requirements.txt',
      manifest: 'requirements.txt',
      registry: 'https://pypi.org/'
    },
    maven: {
      lockfile: 'pom.xml',
      manifest: 'pom.xml',
      registry: 'https://repo1.maven.org/maven2/'
    },
    gradle: {
      lockfile: 'build.gradle',
      manifest: 'build.gradle',
      registry: 'https://repo1.maven.org/maven2/'
    },
    composer: {
      lockfile: 'composer.lock',
      manifest: 'composer.json',
      registry: 'https://packagist.org/'
    },
    cargo: {
      lockfile: 'Cargo.lock',
      manifest: 'Cargo.toml',
      registry: 'https://crates.io/'
    },
    gem: {
      lockfile: 'Gemfile.lock',
      manifest: 'Gemfile',
      registry: 'https://rubygems.org/'
    }
  };

  private licenseCompatibility = {
    'MIT': { type: 'permissive', compatible: true },
    'Apache-2.0': { type: 'permissive', compatible: true },
    'BSD-3-Clause': { type: 'permissive', compatible: true },
    'GPL-3.0': { type: 'copyleft', compatible: false },
    'LGPL-3.0': { type: 'copyleft', compatible: true },
    'AGPL-3.0': { type: 'copyleft', compatible: false },
    'Proprietary': { type: 'proprietary', compatible: false },
    'UNLICENSED': { type: 'unknown', compatible: false }
  };

  /**
   * Scan dependencies for vulnerabilities
   */
  public async scanDependencies(files: Array<{ name: string; content: string }>): Promise<DependencyScanResult> {
    const startTime = Date.now();

    try {
      // Identify package manager files
      const packageFiles = this.identifyPackageFiles(files);
      
      // Parse dependency manifests
      const dependencyTree = await this.buildDependencyTree(packageFiles);
      
      // Scan for vulnerabilities
      const vulnerabilities = await this.scanForVulnerabilities(dependencyTree);
      
      // Check for license issues
      const licenseIssues = await this.analyzeLicenses(dependencyTree);
      
      // Find outdated packages
      const outdatedPackages = await this.findOutdatedPackages(dependencyTree);
      
      // Assess supply chain risks
      const supplyChainRisks = await this.assessSupplyChainRisks(dependencyTree);
      
      // Generate summary and recommendations
      const summary = this.generateSummary(dependencyTree, vulnerabilities, licenseIssues, outdatedPackages, supplyChainRisks);
      const recommendations = this.generateRecommendations(vulnerabilities, licenseIssues, outdatedPackages, supplyChainRisks);

      return {
        summary,
        dependencyTree,
        vulnerabilities,
        licenseIssues,
        outdatedPackages,
        supplyChainRisks,
        recommendations,
        scanMetadata: {
          scanDate: new Date(),
          scanDuration: Date.now() - startTime,
          databasesUsed: this.vulnerabilityDatabases.map(db => db.name),
          toolVersion: '1.0.0'
        }
      };
    } catch (error) {
      throw new Error(`Dependency scan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Identify package manager files in the project
   */
  private identifyPackageFiles(files: Array<{ name: string; content: string }>) {
    const packageFiles: Array<{ 
      name: string; 
      content: string; 
      ecosystem: string; 
      type: 'manifest' | 'lockfile' 
    }> = [];

    files.forEach(file => {
      const filename = file.name.toLowerCase();
      
      for (const [ecosystem, config] of Object.entries(this.packageManagers)) {
        if (filename.endsWith(config.manifest.toLowerCase())) {
          packageFiles.push({
            name: file.name,
            content: file.content,
            ecosystem,
            type: 'manifest'
          });
        } else if (filename.endsWith(config.lockfile.toLowerCase())) {
          packageFiles.push({
            name: file.name,
            content: file.content,
            ecosystem,
            type: 'lockfile'
          });
        }
      }
    });

    return packageFiles;
  }

  /**
   * Build dependency tree from package files
   */
  private async buildDependencyTree(packageFiles: Array<{ name: string; content: string; ecosystem: string; type: string }>): Promise<DependencyTree[]> {
    const dependencyTrees: DependencyTree[] = [];

    for (const file of packageFiles) {
      if (file.type === 'manifest') {
        const tree = await this.parseManifestFile(file);
        if (tree) {
          dependencyTrees.push(tree);
        }
      }
    }

    return dependencyTrees;
  }

  /**
   * Parse package manifest file
   */
  private async parseManifestFile(file: { name: string; content: string; ecosystem: string }): Promise<DependencyTree | null> {
    try {
      let dependencies: Record<string, string> = {};

      switch (file.ecosystem) {
        case 'npm':
        case 'yarn':
          const packageJson = JSON.parse(file.content);
          dependencies = {
            ...packageJson.dependencies || {},
            ...packageJson.devDependencies || {},
            ...packageJson.peerDependencies || {}
          };
          break;

        case 'pip':
          // Parse requirements.txt format
          const lines = file.content.split('\n');
          lines.forEach(line => {
            const match = line.trim().match(/^([a-zA-Z0-9_-]+)([><=!]+)?([\d.]+)?/);
            if (match) {
              dependencies[match[1]] = match[3] || 'latest';
            }
          });
          break;

        case 'maven':
          // Parse pom.xml - simplified XML parsing
          const dependencyMatches = file.content.match(/<dependency>[\s\S]*?<\/dependency>/g);
          if (dependencyMatches) {
            dependencyMatches.forEach(dep => {
              const groupMatch = dep.match(/<groupId>(.*?)<\/groupId>/);
              const artifactMatch = dep.match(/<artifactId>(.*?)<\/artifactId>/);
              const versionMatch = dep.match(/<version>(.*?)<\/version>/);
              
              if (groupMatch && artifactMatch) {
                const name = `${groupMatch[1]}:${artifactMatch[1]}`;
                dependencies[name] = versionMatch ? versionMatch[1] : 'latest';
              }
            });
          }
          break;

        case 'composer':
          const composerJson = JSON.parse(file.content);
          dependencies = {
            ...composerJson.require || {},
            ...composerJson['require-dev'] || {}
          };
          break;

        case 'cargo':
          // Parse Cargo.toml - simplified TOML parsing
          const cargoLines = file.content.split('\n');
          let inDependencies = false;
          
          cargoLines.forEach(line => {
            if (line.trim() === '[dependencies]') {
              inDependencies = true;
              return;
            }
            if (line.trim().startsWith('[') && line.trim() !== '[dependencies]') {
              inDependencies = false;
              return;
            }
            if (inDependencies) {
              const match = line.match(/^([a-zA-Z0-9_-]+)\s*=\s*"([^"]+)"/);
              if (match) {
                dependencies[match[1]] = match[2];
              }
            }
          });
          break;
      }

      // Create dependency tree structure
      const dependencyNodes: DependencyTree[] = [];
      
      for (const [name, version] of Object.entries(dependencies)) {
        const packageInfo = await this.getPackageInfo(name, version, file.ecosystem);
        const vulnerabilities = await this.getPackageVulnerabilities(name, version, file.ecosystem);
        
        dependencyNodes.push({
          package: packageInfo,
          dependencies: [], // Transitive dependencies would be resolved recursively
          vulnerabilities,
          riskScore: this.calculatePackageRiskScore(vulnerabilities),
          depth: 1,
          isDirect: true
        });
      }

      return {
        package: {
          name: file.name,
          version: '1.0.0',
          ecosystem: file.ecosystem,
          description: 'Project root'
        },
        dependencies: dependencyNodes,
        vulnerabilities: [],
        riskScore: 0,
        depth: 0,
        isDirect: true
      };

    } catch (error) {
      console.error(`Failed to parse ${file.name}:`, error);
      return null;
    }
  }

  /**
   * Get package information from registry
   */
  private async getPackageInfo(name: string, version: string, ecosystem: string): Promise<PackageInfo> {
    // In a real implementation, this would fetch from package registries
    return {
      name,
      version,
      ecosystem,
      description: `Package ${name}`,
      license: 'Unknown',
      deprecated: false
    };
  }

  /**
   * Get vulnerabilities for a specific package
   */
  private async getPackageVulnerabilities(name: string, version: string, ecosystem: string): Promise<Vulnerability[]> {
    // In a real implementation, this would query vulnerability databases
    const vulnerabilities: Vulnerability[] = [];

    // Simulate some vulnerabilities for common packages
    if (name.includes('lodash') && version < '4.17.21') {
      vulnerabilities.push({
        id: 'CVE-2021-23337',
        title: 'Prototype Pollution in lodash',
        description: 'A vulnerability in lodash allows prototype pollution',
        severity: 'High',
        cvss: {
          version: '3.1',
          score: 7.2,
          vector: 'CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H',
          baseScore: 7.2
        },
        cwe: ['CWE-1321'],
        references: [
          'https://nvd.nist.gov/vuln/detail/CVE-2021-23337',
          'https://github.com/lodash/lodash/commit/c4847ebe7d14540bb28a8b932a9ce1b9f4a69ba0'
        ],
        publishedDate: new Date('2021-02-15'),
        lastModified: new Date('2021-02-15'),
        affectedVersions: ['<4.17.21'],
        patchedVersions: ['>=4.17.21'],
        exploitAvailable: true,
        exploitMaturity: 'proof-of-concept',
        recommendedAction: 'Update to version 4.17.21 or later',
        vendorAdvisory: 'https://github.com/lodash/lodash/security/advisories/GHSA-35jh-r3h4-6jhm'
      });
    }

    return vulnerabilities;
  }

  /**
   * Scan all dependencies for vulnerabilities
   */
  private async scanForVulnerabilities(dependencyTrees: DependencyTree[]): Promise<Array<{
    package: string;
    version: string;
    vulnerability: Vulnerability;
    path: string[];
    fixAvailable: boolean;
    fixVersion?: string;
  }>> {
    const vulnerabilities: Array<{
      package: string;
      version: string;
      vulnerability: Vulnerability;
      path: string[];
      fixAvailable: boolean;
      fixVersion?: string;
    }> = [];

    const scanTree = (tree: DependencyTree, path: string[] = []) => {
      tree.vulnerabilities.forEach(vuln => {
        vulnerabilities.push({
          package: tree.package.name,
          version: tree.package.version,
          vulnerability: vuln,
          path: [...path, tree.package.name],
          fixAvailable: vuln.patchedVersions.length > 0,
          fixVersion: vuln.patchedVersions[0]
        });
      });

      tree.dependencies.forEach(dep => {
        scanTree(dep, [...path, tree.package.name]);
      });
    };

    dependencyTrees.forEach(tree => scanTree(tree));
    return vulnerabilities;
  }

  /**
   * Analyze license compatibility
   */
  private async analyzeLicenses(dependencyTrees: DependencyTree[]): Promise<LicenseIssue[]> {
    const licenseIssues: LicenseIssue[] = [];

    const checkLicenses = (tree: DependencyTree) => {
      const license = tree.package.license;
      if (license) {
        const compatibility = this.licenseCompatibility[license];
        if (compatibility && !compatibility.compatible) {
          licenseIssues.push({
            package: tree.package.name,
            license,
            type: compatibility.type === 'copyleft' ? 'copyleft' : 'incompatible',
            severity: compatibility.type === 'copyleft' ? 'Medium' : 'High',
            description: `Package uses ${license} license which may have compatibility issues`,
            recommendation: `Review license terms and consider alternatives`
          });
        }
      }

      tree.dependencies.forEach(dep => checkLicenses(dep));
    };

    dependencyTrees.forEach(tree => checkLicenses(tree));
    return licenseIssues;
  }

  /**
   * Find outdated packages
   */
  private async findOutdatedPackages(dependencyTrees: DependencyTree[]): Promise<OutdatedPackage[]> {
    const outdatedPackages: OutdatedPackage[] = [];

    // In a real implementation, this would check package registries for latest versions
    // For now, we'll simulate some outdated packages

    return outdatedPackages;
  }

  /**
   * Assess supply chain security risks
   */
  private async assessSupplyChainRisks(dependencyTrees: DependencyTree[]): Promise<SupplyChainRisk[]> {
    const risks: SupplyChainRisk[] = [];

    const assessTree = (tree: DependencyTree) => {
      // Check for typosquatting risks
      if (this.isPotentialTyposquat(tree.package.name)) {
        risks.push({
          package: tree.package.name,
          riskType: 'typosquatting',
          severity: 'Medium',
          description: 'Package name resembles a popular package',
          indicators: ['Similar name to popular package'],
          mitigation: 'Verify package authenticity and author'
        });
      }

      // Check for suspicious maintainer patterns
      if (tree.package.maintainers && tree.package.maintainers.length === 1) {
        risks.push({
          package: tree.package.name,
          riskType: 'maintainer_risk',
          severity: 'Low',
          description: 'Package has only one maintainer',
          indicators: ['Single maintainer', 'Bus factor of 1'],
          mitigation: 'Monitor package for maintenance issues'
        });
      }

      tree.dependencies.forEach(dep => assessTree(dep));
    };

    dependencyTrees.forEach(tree => assessTree(tree));
    return risks;
  }

  /**
   * Generate scan summary
   */
  private generateSummary(
    dependencyTrees: DependencyTree[],
    vulnerabilities: any[],
    licenseIssues: LicenseIssue[],
    outdatedPackages: OutdatedPackage[],
    supplyChainRisks: SupplyChainRisk[]
  ) {
    let totalPackages = 0;
    let directDependencies = 0;

    const countPackages = (tree: DependencyTree) => {
      totalPackages++;
      if (tree.isDirect) directDependencies++;
      tree.dependencies.forEach(dep => countPackages(dep));
    };

    dependencyTrees.forEach(tree => countPackages(tree));

    const criticalVulns = vulnerabilities.filter(v => v.vulnerability.severity === 'Critical').length;
    const highVulns = vulnerabilities.filter(v => v.vulnerability.severity === 'High').length;
    const mediumVulns = vulnerabilities.filter(v => v.vulnerability.severity === 'Medium').length;
    const lowVulns = vulnerabilities.filter(v => v.vulnerability.severity === 'Low').length;

    const overallRiskScore = Math.min(100, 
      (criticalVulns * 25) + (highVulns * 10) + (mediumVulns * 5) + (lowVulns * 1)
    );

    return {
      totalPackages,
      directDependencies,
      transitiveDependencies: totalPackages - directDependencies,
      vulnerablePackages: new Set(vulnerabilities.map(v => v.package)).size,
      criticalVulnerabilities: criticalVulns,
      highVulnerabilities: highVulns,
      mediumVulnerabilities: mediumVulns,
      lowVulnerabilities: lowVulns,
      outdatedPackages: outdatedPackages.length,
      licenseIssues: licenseIssues.length,
      supplyChainRisks: supplyChainRisks.length,
      overallRiskScore
    };
  }

  /**
   * Generate recommendations
   */
  private generateRecommendations(
    vulnerabilities: any[],
    licenseIssues: LicenseIssue[],
    outdatedPackages: OutdatedPackage[],
    supplyChainRisks: SupplyChainRisk[]
  ) {
    const recommendations = [];

    if (vulnerabilities.length > 0) {
      const criticalVulns = vulnerabilities.filter(v => v.vulnerability.severity === 'Critical');
      if (criticalVulns.length > 0) {
        recommendations.push({
          priority: 'Critical' as const,
          category: 'security' as const,
          title: 'Critical vulnerabilities found',
          description: `${criticalVulns.length} critical vulnerabilities detected`,
          action: 'Update vulnerable packages immediately',
          packages: criticalVulns.map(v => v.package)
        });
      }
    }

    if (licenseIssues.length > 0) {
      recommendations.push({
        priority: 'Medium' as const,
        category: 'license' as const,
        title: 'License compatibility issues',
        description: `${licenseIssues.length} packages have license issues`,
        action: 'Review license compatibility for compliance',
        packages: licenseIssues.map(l => l.package)
      });
    }

    return recommendations;
  }

  // Helper methods
  private calculatePackageRiskScore(vulnerabilities: Vulnerability[]): number {
    let score = 0;
    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'Critical': score += 25; break;
        case 'High': score += 10; break;
        case 'Medium': score += 5; break;
        case 'Low': score += 1; break;
      }
    });
    return Math.min(100, score);
  }

  private isPotentialTyposquat(packageName: string): boolean {
    const popularPackages = [
      'react', 'lodash', 'express', 'axios', 'webpack', 'babel',
      'eslint', 'prettier', 'typescript', 'node', 'npm', 'yarn'
    ];
    
    return popularPackages.some(popular => 
      this.levenshteinDistance(packageName.toLowerCase(), popular) <= 2 && 
      packageName.toLowerCase() !== popular
    );
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }
}